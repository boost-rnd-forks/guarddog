import logging
import os
from typing import List
import subprocess
import shutil

from guarddog.scanners.maven_package_scanner import MavenPackageScanner
from guarddog.scanners.scanner import Dependency, ProjectScanner, DependencyVersion
from ..utils.exceptions import DependencyGenerationError
from ..utils.archives import find_pom

log = logging.getLogger("guarddog")

TMP_DEPENDENCIES_PATH = "/tmp/maven_dependencies.txt"


class MavenDependenciesScanner(ProjectScanner):
    def __init__(self) -> None:
        super().__init__(MavenPackageScanner())

    def format_requirements(self, raw_requirements: str) -> list[str]:
        """
        Parses the raw output of `mvn dependency:tree`
        and extracts only the direct dependencies.

        Args:
            raw_requirements (str): output of `mvn dependency:tree`

        Returns:
            list[str]: direct dependencies cleaned (groupId:artifactId:type:version:scope)
        """
        direct_dependencies: list[str] = []
        for line in raw_requirements.splitlines():
            # line = line.strip()
            if not line.startswith("[INFO]"):
                continue

            content = line[len("[INFO]") :].lstrip()

            # Capture only direct dependencies
            if content.startswith("+-"):
                direct_dependencies.append(content.strip()[2:].lstrip())
            elif content.startswith("\\-"):  # last direct dependency
                direct_dependencies.append(content.strip()[2:].lstrip())
                break  # stop when nested level starts

        return direct_dependencies

    def parse_requirements(self, raw_requirements: str) -> List[Dependency]:
        """
        Parses requirements generated in `raw_requirements` (str)
        Expects raw_requirements to be the content of
        a txt file generated by `mvn dependency:tree`
        Returns:
            list[Dependency]:
                - name (str): group_id:artifact_id
                - version (str)
        """
        log.debug("Parsing requirements generated ...")
        dependencies: List[Dependency] = []
        idx = 0
        try:
            formatted_dep: list[str] = self.format_requirements(raw_requirements)
            for dep in formatted_dep:
                log.debug(dep)
                idx += 1
                try:
                    group_id, artifact_id, type, version, phase = dep.split(":")
                except Exception as e:
                    raise ValueError(f"Invalid maven dependency value: {e}.")
                name = group_id + ":" + artifact_id
                versions: set[DependencyVersion] = set()
                versions.add(DependencyVersion(version=version, location=idx))
                dependency = Dependency(name=name, versions=versions)
                dependencies.append(dependency)
        finally:
            if os.path.exists(TMP_DEPENDENCIES_PATH):
                os.remove(TMP_DEPENDENCIES_PATH)
        return dependencies

    def find_requirements(self, directory: str) -> list[str]:
        """
        Extracts direct dependencies of a Maven project using `mvn dependency:tree`.
        Args:
            directory (str): Path to the root directory of the Maven project
        Returns:
            List[str]: Path to the written file containing the output of the cmd
        """
        log.debug("Generating the dependency tree...")
        if not os.path.isdir(directory):
            raise ValueError("The provided path must be a java project directory.")

        resulting_path: list[str] = []

        if not os.path.isfile(os.path.join(directory, "pom.xml")):
            log.debug("looking for pom")
            pom_path: str = find_pom(directory)
            if pom_path:
                shutil.copy(pom_path, directory)
            else:
                raise DependencyGenerationError(f"No pom.xml found in {directory}.")

        try:
            log.warning(
                "Security warning: Running 'mvn dependency:tree' in directory '%s'. "
                "If this directory is untrusted, this may execute arbitrary code defined in the Maven project. "
                "Proceed with caution.",
                directory,
            )
            with open(TMP_DEPENDENCIES_PATH, "w") as f:
                subprocess.run(
                    ["mvn", "dependency:tree"],
                    cwd=directory,
                    stdout=f,
                    stderr=subprocess.STDOUT,  # optional: capture stderr too
                    check=True,
                )

            resulting_path.append(TMP_DEPENDENCIES_PATH)
            return resulting_path

        except Exception as e:
            raise DependencyGenerationError(f"Failed to run mvn dependency:tree: {e}")
